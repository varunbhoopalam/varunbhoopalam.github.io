The life of a file - A live talk by Evan Czaplicki found [here](https://www.youtube.com/watch?v=XpDsk374LDE)

The premise to this talk was this question. "How do you grow Elm code?" Evan thought this question was rooted JavaScript context. This context asserts that with JavaScript, the chance of a mutation induced bug goes to 1 as a code file grows larger. The other is that there is risk in breaking the system with refactoring because of un-seen mutation. These are not problems in Elm. Elm is declarative and has a compiler to help with refactors. So, this dismisses a common held notion that large files are inherently bad. 

Evan showed an example of two very similar views in a UI. These only appeared similar as the business and logic requirements ended up being quite different between them. The resulting data structures thus were quite different between them. Each file ended up with different custom types to accompany the differing requirements and made it logical to separate the type and logic around the type into it's own file. Evan recommends to do this organically. He asks not to introduce pre-mature generalization or refactoring as this could end with the wrong abstraction. To prevent future bugs with shared code, he said to limit what the module exposed to only what was absolutely necessary. By not exposing the implementation of the type, future bugs can be avoided. If a module/custom type was used in 10 places in the code, a refactor to the underlying implementation of the code should not cause bugs with those 10 places if the public api remains the same.

Really focus on the data model. Solve problems in front of you, not potential future ones.
